<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0a0a0a">
    <title>üí≠ Capture</title>
    <link rel="manifest" href="manifest.json">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&display=swap');

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --bg: #0a0a0a;
            --surface: #141414;
            --border: #2a2a2a;
            --text: #e8e8e8;
            --muted: #666;
            --accent: #4ade80;
            --warning: #fb923c;
            --radius: 12px;
        }

        html, body {
            height: 100%;
            background: var(--bg);
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            -webkit-tap-highlight-color: transparent;
        }

        .app {
            min-height: 100%;
            display: flex;
            flex-direction: column;
            padding: 16px;
            padding-top: env(safe-area-inset-top, 16px);
            padding-bottom: env(safe-area-inset-bottom, 16px);
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .logo {
            font-size: 14px;
            color: var(--muted);
            letter-spacing: 0.5px;
        }

        .status {
            font-size: 11px;
            color: var(--muted);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--accent);
            animation: pulse 2s infinite;
        }

        .status-dot.syncing {
            background: var(--warning);
            animation: pulse 0.8s infinite;
        }

        .status-dot.offline {
            background: var(--muted);
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .capture-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        textarea, input[type="text"].thought-input {
            flex: 1;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 16px;
            color: var(--text);
            font-family: inherit;
            font-size: 16px;
            line-height: 1.6;
            outline: none;
            transition: border-color 0.2s;
        }

        textarea {
            min-height: 80px; /* ~3 lines */
            resize: none;
        }

        input[type="text"].thought-input {
            min-height: auto;
        }

        textarea:focus, input[type="text"].thought-input:focus {
            border-color: var(--accent);
        }

        textarea::placeholder, input[type="text"].thought-input::placeholder {
            color: var(--muted);
        }

        .actions {
            display: flex;
            gap: 8px;
        }

        button {
            flex: 1;
            padding: 14px 20px;
            border: none;
            border-radius: var(--radius);
            font-family: inherit;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn-primary {
            background: var(--accent);
            color: var(--bg);
        }

        .btn-primary:active {
            transform: scale(0.98);
            opacity: 0.9;
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-icon {
            flex: none;
            width: 46px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .history {
            margin-top: 24px;
        }

        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .history-title {
            font-size: 12px;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .export-btn {
            font-size: 11px;
            padding: 6px 12px;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--muted);
            flex: none;
        }

        .thoughts-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 300px;
            overflow-y: auto;
        }

        .thought-item {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 12px;
            position: relative;
        }

        .thought-item.synced::after {
            content: '‚úì';
            position: absolute;
            top: 8px;
            right: 8px;
            color: var(--accent);
            font-size: 10px;
        }

        .thought-meta {
            font-size: 10px;
            color: var(--muted);
            margin-bottom: 6px;
            display: flex;
            gap: 12px;
        }

        .thought-text {
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .empty-state {
            text-align: center;
            padding: 32px;
            color: var(--muted);
            font-size: 13px;
        }

        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--accent);
            color: var(--bg);
            padding: 12px 24px;
            border-radius: 100px;
            font-size: 13px;
            font-weight: 500;
            opacity: 0;
            transition: all 0.3s;
            pointer-events: none;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
            z-index: 1000;
            padding: 16px;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 24px;
            max-width: 500px;
            width: 100%;
        }

        .modal-header {
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 16px;
        }

        .modal-body {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin-bottom: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .form-label {
            font-size: 12px;
            color: var(--muted);
        }

        input {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px 12px;
            color: var(--text);
            font-family: inherit;
            font-size: 13px;
            outline: none;
        }

        input:focus {
            border-color: var(--accent);
        }

        .modal-footer {
            display: flex;
            gap: 8px;
        }

        .help-text {
            font-size: 11px;
            color: var(--muted);
            line-height: 1.4;
        }

        .help-text a {
            color: var(--accent);
            text-decoration: none;
        }

        .sync-banner {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 12px;
            margin-bottom: 16px;
            font-size: 12px;
            color: var(--muted);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sync-banner button {
            padding: 6px 12px;
            font-size: 11px;
            flex: none;
        }

        .update-banner {
            background: var(--warning);
            color: var(--bg);
            border: none;
            border-radius: var(--radius);
            padding: 12px;
            margin-bottom: 16px;
            font-size: 12px;
            font-weight: 500;
            display: none;
            justify-content: space-between;
            align-items: center;
        }

        .update-banner button {
            padding: 6px 12px;
            font-size: 11px;
            flex: none;
            background: var(--bg);
            color: var(--warning);
        }
    </style>
</head>
<body>
    <div class="app">
        <header>
            <div class="logo">üí≠ thought capture</div>
            <div class="status">
                <span class="status-dot" id="statusDot"></span>
                <span id="statusText">ready</span>
            </div>
        </header>

        <div id="updateBanner" class="update-banner">
            <span>üéâ New version available!</span>
            <button class="btn-secondary" onclick="reloadApp()">Update Now</button>
        </div>

        <div id="syncBanner" class="sync-banner" style="display: none;">
            <span>Auto-sync not configured</span>
            <button class="btn-secondary" onclick="openSettings()">Setup</button>
        </div>

        <div class="capture-area">
            <textarea id="thoughtInput" placeholder="What's on your mind?" autofocus></textarea>
            <div class="actions">
                <button class="btn-primary" onclick="captureThought()">Capture</button>
                <button class="btn-secondary" onclick="exportToday()">üì• Today</button>
                <button class="btn-secondary btn-icon" onclick="openSettings()" title="Settings">‚öôÔ∏è</button>
            </div>
        </div>

        <div class="history">
            <div class="history-header">
                <span class="history-title">Recent</span>
            </div>
            <div class="thoughts-list" id="thoughtsList"></div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <!-- Settings Modal -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">Settings</div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Input Mode</label>
                    <select id="inputMode" style="background: var(--bg); border: 1px solid var(--border); border-radius: 8px; padding: 10px 12px; color: var(--text); font-family: inherit; font-size: 13px;">
                        <option value="multiline">Multi-line (Cmd/Ctrl+Enter to capture)</option>
                        <option value="single">Single-line (Enter to capture)</option>
                    </select>
                    <div class="help-text">
                        Multi-line for longer thoughts, single-line for quick captures
                    </div>
                </div>

                <div style="border-top: 1px solid var(--border); margin: 16px 0;"></div>
                <div style="font-size: 12px; color: var(--muted); margin-bottom: 16px;">GitHub Auto-Sync</div>
                <div class="form-group">
                    <label class="form-label">GitHub Personal Access Token</label>
                    <input type="password" id="githubToken" placeholder="ghp_xxxxxxxxxxxxx">
                    <div class="help-text">
                        Create at <a href="https://github.com/settings/tokens/new?scopes=repo" target="_blank">github.com/settings/tokens</a>
                        <br>Required scope: <strong>repo</strong> (Full control of private repositories)
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Repository (owner/repo)</label>
                    <input type="text" id="githubRepo" placeholder="ishakuta/obsidian-vault">
                </div>

                <div class="form-group">
                    <label class="form-label">File Path (in repo)</label>
                    <input type="text" id="githubPath" placeholder="Daily Notes/{date}.md" value="Daily Notes/{date}.md">
                    <div class="help-text">
                        Use <strong>{date}</strong> for current date (YYYY-MM-DD)
                        <br>Example: Daily Notes/2025-12-28.md
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Sync Mode</label>
                    <select id="syncMode" style="background: var(--bg); border: 1px solid var(--border); border-radius: 8px; padding: 10px 12px; color: var(--text); font-family: inherit; font-size: 13px;">
                        <option value="auto">Auto (Background Sync)</option>
                        <option value="manual">Manual Only</option>
                    </select>
                    <div class="help-text" id="syncModeHelp">
                        Auto mode syncs in background when online (battery-efficient)
                    </div>
                </div>
            </div>
            <div class="modal-footer" style="display: flex; flex-direction: column; gap: 12px;">
                <div style="display: flex; gap: 8px; width: 100%;">
                    <button class="btn-secondary" style="flex: 1;" onclick="exportAll()">üì• Export All (.md)</button>
                    <button class="btn-secondary" onclick="closeSettings()">Cancel</button>
                    <button class="btn-primary" onclick="saveSettings()">Save</button>
                </div>
                <div style="font-size: 10px; color: var(--muted); text-align: center;" id="versionDisplay">
                    Version loading...
                </div>
            </div>
        </div>
    </div>

    <script>
        const APP_VERSION = '1.0.0';
        const STORAGE_KEY = 'thoughts';
        const SETTINGS_KEY = 'github_sync_settings';
        const SYNC_QUEUE_KEY = 'sync_queue';
        const INPUT_MODE_KEY = 'input_mode';
        let currentLocation = null;
        let syncSettings = null;
        let inputMode = 'multiline'; // default

        // Load settings
        function loadSettings() {
            const stored = localStorage.getItem(SETTINGS_KEY);
            return stored ? JSON.parse(stored) : null;
        }

        syncSettings = loadSettings();
        inputMode = localStorage.getItem(INPUT_MODE_KEY) || 'multiline';

        // Request location on load
        if ('geolocation' in navigator) {
            navigator.geolocation.getCurrentPosition(
                pos => {
                    currentLocation = {
                        lat: pos.coords.latitude.toFixed(5),
                        lon: pos.coords.longitude.toFixed(5)
                    };
                    updateStatus('ready');
                },
                err => {
                    updateStatus('ready');
                },
                { enableHighAccuracy: false, timeout: 5000 }
            );
        }

        function updateStatus(status, text) {
            const dot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');

            dot.className = 'status-dot';

            if (status === 'syncing') {
                dot.classList.add('syncing');
                statusText.textContent = text || 'syncing...';
            } else if (status === 'offline') {
                dot.classList.add('offline');
                statusText.textContent = text || 'offline';
            } else {
                const unsynced = getUnsyncedCount();
                if (unsynced > 0) {
                    statusText.textContent = `${unsynced} queued`;
                } else {
                    statusText.textContent = text || 'synced';
                }
            }
        }

        function getThoughts() {
            return JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
        }

        function saveThoughts(thoughts) {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(thoughts));
        }

        function getUnsyncedCount() {
            const thoughts = getThoughts();
            return thoughts.filter(t => !t.synced).length;
        }

        function captureThought() {
            const input = document.getElementById('thoughtInput');
            const text = input.value.trim();

            if (!text) return;

            const thought = {
                id: Date.now(),
                text,
                timestamp: new Date().toISOString(),
                location: currentLocation,
                synced: false
            };

            const thoughts = getThoughts();
            thoughts.unshift(thought);
            saveThoughts(thoughts);

            input.value = '';
            renderThoughts();
            showToast('Captured ‚úì');

            // Haptic feedback
            if ('vibrate' in navigator) {
                navigator.vibrate(10);
            }

            // Queue for sync
            if (syncSettings && syncSettings.syncMode === 'auto') {
                queueSync();
            }
        }

        function formatDate(iso) {
            const d = new Date(iso);
            return d.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function renderThoughts() {
            const list = document.getElementById('thoughtsList');
            const thoughts = getThoughts().slice(0, 10); // Show last 10

            if (!thoughts.length) {
                list.innerHTML = '<div class="empty-state">No thoughts yet. Start capturing!</div>';
                return;
            }

            list.innerHTML = thoughts.map(t => `
                <div class="thought-item ${t.synced ? 'synced' : ''}">
                    <div class="thought-meta">
                        <span>${formatDate(t.timestamp)}</span>
                        ${t.location ? `<span>üìç ${t.location.lat}, ${t.location.lon}</span>` : ''}
                    </div>
                    <div class="thought-text">${escapeHtml(t.text)}</div>
                </div>
            `).join('');

            updateStatus('ready');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function thoughtToMarkdown(t) {
            const d = new Date(t.timestamp);
            const time = d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
            const locationStr = t.location ? ` | üìç [${t.location.lat}, ${t.location.lon}](https://www.google.com/maps?q=${t.location.lat},${t.location.lon})` : '';
            return `- **${time}**${locationStr}\n  ${t.text.replace(/\n/g, '\n  ')}`;
        }

        function exportToday() {
            const thoughts = getThoughts();
            const today = new Date().toISOString().split('T')[0];
            const todayThoughts = thoughts.filter(t => t.timestamp.startsWith(today));

            if (!todayThoughts.length) {
                showToast('No thoughts today');
                return;
            }

            const md = generateMarkdown(todayThoughts, today);
            downloadFile(`thoughts-${today}.md`, md);
            showToast('Exported ‚úì');
        }

        function exportAll() {
            const thoughts = getThoughts();

            if (!thoughts.length) {
                showToast('No thoughts to export');
                return;
            }

            // Group by date
            const byDate = {};
            thoughts.forEach(t => {
                const date = t.timestamp.split('T')[0];
                if (!byDate[date]) byDate[date] = [];
                byDate[date].push(t);
            });

            let md = '# Captured Thoughts\n\n';
            Object.keys(byDate).sort().reverse().forEach(date => {
                md += `## ${date}\n\n`;
                byDate[date].reverse().forEach(t => {
                    md += thoughtToMarkdown(t) + '\n\n';
                });
            });

            downloadFile(`thoughts-export-${new Date().toISOString().split('T')[0]}.md`, md);
            showToast('Exported ‚úì');
        }

        function generateMarkdown(thoughts, date) {
            let md = `# Thoughts - ${date}\n\n`;
            thoughts.reverse().forEach(t => {
                md += thoughtToMarkdown(t) + '\n\n';
            });
            return md;
        }

        function downloadFile(filename, content) {
            const blob = new Blob([content], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
        }

        // Settings Modal
        function openSettings() {
            const modal = document.getElementById('settingsModal');

            // Load input mode
            document.getElementById('inputMode').value = inputMode;

            // Load sync settings
            if (syncSettings) {
                document.getElementById('githubToken').value = syncSettings.token || '';
                document.getElementById('githubRepo').value = syncSettings.repo || '';
                document.getElementById('githubPath').value = syncSettings.path || 'Daily Notes/{date}.md';
                document.getElementById('syncMode').value = syncSettings.syncMode || 'auto';
            }

            // Update help text based on browser support
            const helpText = document.getElementById('syncModeHelp');
            if (isBrowserSyncSupported()) {
                helpText.innerHTML = 'Auto mode uses Background Sync API (syncs even when app is backgrounded)';
            } else {
                helpText.innerHTML = '‚ö†Ô∏è Background Sync not supported on this device (iOS/Safari). Auto mode will sync immediately instead.';
            }

            // Show version
            document.getElementById('versionDisplay').textContent = `Version ${APP_VERSION}`;

            modal.classList.add('show');
        }

        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('show');
        }

        async function saveSettings() {
            const newInputMode = document.getElementById('inputMode').value;
            const token = document.getElementById('githubToken').value.trim();
            const repo = document.getElementById('githubRepo').value.trim();
            const path = document.getElementById('githubPath').value.trim();
            const syncMode = document.getElementById('syncMode').value;

            // Save input mode
            if (newInputMode !== inputMode) {
                inputMode = newInputMode;
                localStorage.setItem(INPUT_MODE_KEY, inputMode);
                updateInputMode();
            }

            // Save sync settings if filled
            if (token && repo && path) {
                syncSettings = { token, repo, path, syncMode };
                localStorage.setItem(SETTINGS_KEY, JSON.stringify(syncSettings));
                updateSyncBanner();

                // Register service worker if auto mode
                if (syncMode === 'auto' && 'serviceWorker' in navigator) {
                    await registerServiceWorker();
                    console.log('[App] Service Worker registration requested');
                }

                // Try to sync immediately
                if (getUnsyncedCount() > 0) {
                    syncToGitHub();
                }
            }

            closeSettings();
            showToast('Settings saved ‚úì');
        }

        function updateInputMode() {
            const container = document.querySelector('.capture-area');
            const oldInput = document.getElementById('thoughtInput');
            const currentValue = oldInput.value;

            // Remove old input
            oldInput.remove();

            // Create new input based on mode
            let newInput;
            if (inputMode === 'single') {
                newInput = document.createElement('input');
                newInput.type = 'text';
                newInput.className = 'thought-input';
                newInput.id = 'thoughtInput';
                newInput.placeholder = "What's on your mind? (Press Enter to capture)";
                newInput.autofocus = true;
                newInput.value = currentValue;

                // Enter key captures
                newInput.addEventListener('keydown', e => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        captureThought();
                    }
                });
            } else {
                newInput = document.createElement('textarea');
                newInput.id = 'thoughtInput';
                newInput.placeholder = "What's on your mind?";
                newInput.autofocus = true;
                newInput.value = currentValue;

                // Cmd/Ctrl+Enter captures
                newInput.addEventListener('keydown', e => {
                    if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
                        e.preventDefault();
                        captureThought();
                    }
                });
            }

            // Insert before actions div
            const actionsDiv = container.querySelector('.actions');
            container.insertBefore(newInput, actionsDiv);
            newInput.focus();
        }

        function updateSyncBanner() {
            const banner = document.getElementById('syncBanner');
            if (!syncSettings) {
                banner.style.display = 'flex';
            } else {
                banner.style.display = 'none';
            }
        }

        // GitHub Sync
        async function syncToGitHub() {
            if (!syncSettings) {
                showToast('Configure sync first');
                openSettings();
                return;
            }

            const thoughts = getThoughts();
            const unsynced = thoughts.filter(t => !t.synced);

            if (unsynced.length === 0) {
                showToast('Already synced ‚úì');
                return;
            }

            updateStatus('syncing');

            try {
                // Group by date
                const byDate = {};
                unsynced.forEach(t => {
                    const date = t.timestamp.split('T')[0];
                    if (!byDate[date]) byDate[date] = [];
                    byDate[date].push(t);
                });

                // Sync each date
                for (const date of Object.keys(byDate)) {
                    const dayThoughts = byDate[date];
                    await syncDayToGitHub(date, dayThoughts);
                }

                // Mark as synced
                thoughts.forEach(t => {
                    if (!t.synced) t.synced = true;
                });
                saveThoughts(thoughts);

                renderThoughts();
                showToast(`Synced ${unsynced.length} thoughts ‚úì`);
                updateStatus('ready');
            } catch (err) {
                console.error('Sync failed:', err);
                showToast('Sync failed: ' + err.message);
                updateStatus('offline', 'sync failed');
            }
        }

        async function syncDayToGitHub(date, dayThoughts) {
            const path = syncSettings.path.replace('{date}', date);
            const { token, repo } = syncSettings;

            // Get existing file content
            const getUrl = `https://api.github.com/repos/${repo}/contents/${path}`;
            let existingContent = '';
            let sha = null;

            try {
                const getResp = await fetch(getUrl, {
                    headers: {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });

                if (getResp.ok) {
                    const data = await getResp.json();
                    // Properly decode UTF-8 from base64
                    existingContent = decodeURIComponent(escape(atob(data.content)));
                    sha = data.sha;
                }
            } catch (err) {
                // File doesn't exist, will create new
            }

            // Generate markdown for new thoughts
            let newContent = '';
            dayThoughts.reverse().forEach(t => {
                newContent += thoughtToMarkdown(t) + '\n\n';
            });

            // Append to existing or create new
            let finalContent;
            if (existingContent) {
                // Append to existing file
                finalContent = existingContent.trimEnd() + '\n\n' + newContent;
            } else {
                // Create new file with header
                finalContent = `# Thoughts - ${date}\n\n${newContent}`;
            }

            // Commit to GitHub
            const putUrl = `https://api.github.com/repos/${repo}/contents/${path}`;
            const commitMessage = `Add ${dayThoughts.length} thought(s) - ${date}`;

            const putResp = await fetch(putUrl, {
                method: 'PUT',
                headers: {
                    'Authorization': `token ${token}`,
                    'Accept': 'application/vnd.github.v3+json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    message: commitMessage,
                    // Properly encode UTF-8 to base64
                    content: btoa(unescape(encodeURIComponent(finalContent))),
                    sha: sha
                })
            });

            if (!putResp.ok) {
                const error = await putResp.json();
                throw new Error(error.message || 'GitHub API error');
            }
        }

        function queueSync() {
            // Use Background Sync if available
            if (isBrowserSyncSupported()) {
                console.log('[App] Using Background Sync API');
                navigator.serviceWorker.ready.then(registration => {
                    return registration.sync.register('sync-thoughts');
                }).then(() => {
                    console.log('[App] Background sync registered');
                    updateStatus('ready');
                }).catch(err => {
                    console.log('[App] Background sync failed, using immediate sync:', err);
                    syncToGitHub();
                });
            } else {
                // Fallback to immediate sync (iOS, old browsers)
                console.log('[App] Background Sync not supported, using immediate sync');
                syncToGitHub();
            }
        }

        async function registerServiceWorker() {
            if (!('serviceWorker' in navigator)) {
                console.log('[App] Service Worker not supported');
                return null;
            }

            try {
                const registration = await navigator.serviceWorker.register('/thoughts/sw.js');
                console.log('[App] Service Worker registered:', registration.scope);

                // Listen for updates
                registration.addEventListener('updatefound', () => {
                    const newWorker = registration.installing;
                    console.log('[App] Service Worker update found, installing...');

                    newWorker.addEventListener('statechange', () => {
                        console.log('[App] Service Worker state:', newWorker.state);
                        if (newWorker.state === 'activated') {
                            console.log('[App] New Service Worker activated');
                        }
                    });
                });

                // Check for updates every 60 seconds (when app is open)
                setInterval(() => {
                    console.log('[App] Checking for Service Worker updates...');
                    registration.update();
                }, 60000);

                return registration;
            } catch (err) {
                console.error('[App] Service Worker registration failed:', err);
                return null;
            }
        }

        function isBrowserSyncSupported() {
            return 'serviceWorker' in navigator && 'sync' in ServiceWorkerRegistration.prototype;
        }

        // Initialize input mode
        updateInputMode();

        // Click outside modal to close
        document.getElementById('settingsModal').addEventListener('click', e => {
            if (e.target.id === 'settingsModal') {
                closeSettings();
            }
        });

        // Listen for messages from Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.addEventListener('message', event => {
                console.log('[App] Message from SW:', event.data);

                if (event.data.type === 'BACKGROUND_SYNC_REQUESTED') {
                    console.log('[App] Background sync requested by SW');
                    syncToGitHub();
                } else if (event.data.type === 'SW_UPDATED') {
                    console.log('[App] Service Worker updated to:', event.data.version);
                    showUpdateBanner();
                }
            });
        }

        function showUpdateBanner() {
            const banner = document.getElementById('updateBanner');
            banner.style.display = 'flex';
        }

        function reloadApp() {
            console.log('[App] Reloading app to apply updates...');
            window.location.reload();
        }

        // Init
        renderThoughts();
        updateSyncBanner();

        // Register Service Worker on load
        if ('serviceWorker' in navigator) {
            registerServiceWorker();
        }

        // Check for unsynced thoughts on load
        if (syncSettings && syncSettings.syncMode === 'auto' && getUnsyncedCount() > 0) {
            console.log('[App] Found unsynced thoughts on load, syncing...');
            setTimeout(() => syncToGitHub(), 2000);
        }
    </script>
</body>
</html>
